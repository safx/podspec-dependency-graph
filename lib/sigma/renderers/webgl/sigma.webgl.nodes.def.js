!function(){"use strict";sigma.utils.pkg("sigma.webgl.nodes"),sigma.webgl.nodes.def={POINTS:3,ATTRIBUTES:5,addNode:function(o,t,i,r,a){var e=sigma.utils.floatColor(o.color||a("defaultNodeColor"));t[i++]=o[r+"x"],t[i++]=o[r+"y"],t[i++]=o[r+"size"],t[i++]=e,t[i++]=0,t[i++]=o[r+"x"],t[i++]=o[r+"y"],t[i++]=o[r+"size"],t[i++]=e,t[i++]=2*Math.PI/3,t[i++]=o[r+"x"],t[i++]=o[r+"y"],t[i++]=o[r+"size"],t[i++]=e,t[i++]=4*Math.PI/3},render:function(o,t,i,r){var a,e=o.getAttribLocation(t,"a_position"),n=o.getAttribLocation(t,"a_size"),l=o.getAttribLocation(t,"a_color"),c=o.getAttribLocation(t,"a_angle"),s=o.getUniformLocation(t,"u_resolution"),u=o.getUniformLocation(t,"u_matrix"),f=o.getUniformLocation(t,"u_ratio"),_=o.getUniformLocation(t,"u_scale");a=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,a),o.bufferData(o.ARRAY_BUFFER,i,o.DYNAMIC_DRAW),o.uniform2f(s,r.width,r.height),o.uniform1f(f,1/Math.pow(r.ratio,r.settings("nodesPowRatio"))),o.uniform1f(_,r.scalingRatio),o.uniformMatrix3fv(u,!1,r.matrix),o.enableVertexAttribArray(e),o.enableVertexAttribArray(n),o.enableVertexAttribArray(l),o.enableVertexAttribArray(c),o.vertexAttribPointer(e,2,o.FLOAT,!1,this.ATTRIBUTES*Float32Array.BYTES_PER_ELEMENT,0),o.vertexAttribPointer(n,1,o.FLOAT,!1,this.ATTRIBUTES*Float32Array.BYTES_PER_ELEMENT,8),o.vertexAttribPointer(l,1,o.FLOAT,!1,this.ATTRIBUTES*Float32Array.BYTES_PER_ELEMENT,12),o.vertexAttribPointer(c,1,o.FLOAT,!1,this.ATTRIBUTES*Float32Array.BYTES_PER_ELEMENT,16),o.drawArrays(o.TRIANGLES,r.start||0,r.count||i.length/this.ATTRIBUTES)},initProgram:function(o){var t,i,r;return t=sigma.utils.loadShader(o,["attribute vec2 a_position;","attribute float a_size;","attribute float a_color;","attribute float a_angle;","uniform vec2 u_resolution;","uniform float u_ratio;","uniform float u_scale;","uniform mat3 u_matrix;","varying vec4 color;","varying vec2 center;","varying float radius;","void main() {","radius = a_size * u_ratio;","vec2 position = (u_matrix * vec3(a_position, 1)).xy;","center = position * u_scale;","center = vec2(center.x, u_scale * u_resolution.y - center.y);","position = position +","2.0 * radius * vec2(cos(a_angle), sin(a_angle));","position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);","radius = radius * u_scale;","gl_Position = vec4(position, 0, 1);","float c = a_color;","color.b = mod(c, 256.0); c = floor(c / 256.0);","color.g = mod(c, 256.0); c = floor(c / 256.0);","color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;","color.a = 1.0;","}"].join("\n"),o.VERTEX_SHADER),i=sigma.utils.loadShader(o,["precision mediump float;","varying vec4 color;","varying vec2 center;","varying float radius;","void main(void) {","vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);","vec2 m = gl_FragCoord.xy - center;","float diff = radius - sqrt(m.x * m.x + m.y * m.y);","if (diff > 0.0)","gl_FragColor = color;","else","gl_FragColor = color0;","}"].join("\n"),o.FRAGMENT_SHADER),r=sigma.utils.loadProgram(o,[t,i])}}}();